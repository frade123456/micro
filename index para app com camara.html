<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="UTF-8" />
  <title>OCR com Ajuste, Zoom e Pan</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body {
      margin: 0; padding: 0;
      font-family: Calibri, sans-serif;
      background: #fff;
      user-select: none;
    }
    #container {
      position: relative;
      width: 100vw;
      height: 80vh;
      background: #eee;
      overflow: hidden;
      touch-action: none;
      cursor: grab;
    }
    #image-wrapper {
      position: absolute;
      top: 0; left: 0;
      will-change: transform;
      user-select: none;
      -webkit-user-drag: none;
    }
    #preview {
      display: block;
      position: absolute;
      top: 0; left: 0;
      transform-origin: 0 0;
      user-select: none;
      -webkit-user-drag: none;
      max-width: none;
      max-height: none;
    }
    #ocr-region {
      position: absolute;
      width: 60vw;
      height: 10vw;
      left: 50%;
      top: 40%;
      transform: translate(-50%, -50%);
      border: 2px dashed #ffb800;
      background: rgba(255, 255, 0, 0.1);
      z-index: 10;
      cursor: move;
      touch-action: none;
    }
    .resize-handle {
      width: 16px;
      height: 16px;
      background: #ffb800;
      position: absolute;
      right: -8px;
      bottom: -8px;
      cursor: se-resize;
      border-radius: 50%;
      border: 2px solid #000;
      z-index: 11;
    }
    #button-bar {
      display: flex;
      justify-content: center;
      gap: 1em;
      margin: 1em auto 0 auto;
      max-width: 90vw;
    }
    #button-bar button {
      flex: 1;
      padding: 1em 0;
      background: #39f;
      color: white;
      font-size: 1.1em;
      font-weight: bold;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      user-select: none;
    }
    #result {
      margin: 1em auto;
      text-align: center;
      font-size: 1.1em;
      font-weight: bold;
      max-width: 90vw;
      word-wrap: break-word;
    }
  </style>
</head>
<body>

  <input type="file" accept="image/*" capture="environment" id="camera-input" style="display:none;" />

  <div id="button-bar">
    <button id="capture-btn">Tirar Foto</button>
    <button id="ocr-btn" disabled>Ler Texto</button>
  </div>

  <div id="container">
    <div id="image-wrapper">
      <img id="preview" src="" alt="Pré" />
    </div>
    <div id="ocr-region">
      <div class="resize-handle"></div>
    </div>
  </div>

  <div id="result">Resultado aparecerá aqui…</div>

  <canvas id="canvas" style="display:none;"></canvas>

  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>
  <script>
    const input = document.getElementById('camera-input');
    const preview = document.getElementById('preview');
    const imageWrapper = document.getElementById('image-wrapper');
    const container = document.getElementById('container');
    const resultDiv = document.getElementById('result');
    const ocrRegion = document.getElementById('ocr-region');
    const handle = ocrRegion.querySelector('.resize-handle');
    const ocrBtn = document.getElementById('ocr-btn');

    // Transform state for image pan & zoom
    let scale = 1, originX = 0, originY = 0;

    // Flags for pan and zoom
    let isPanning = false, startPanX = 0, startPanY = 0;

    // Handle image load and center it inside container
    input.addEventListener('change', () => {
      const file = input.files[0];
      if (!file) return;

      const img = new Image();
      img.src = URL.createObjectURL(file);
      img.onload = () => {
        preview.src = img.src;

        // Reset styles and states
        preview.style.width = '';
        preview.style.height = '';
        scale = 1;

        // Center imageWrapper inside container:
        originX = (container.clientWidth - img.width) / 2;
        originY = (container.clientHeight - img.height) / 2;

        updateTransform();

        ocrBtn.disabled = false;
        resultDiv.textContent = 'Ajuste a imagem e a área OCR, depois clique em "Ler Texto".';
      };
    });

    // Trigger file input
    document.getElementById('capture-btn').addEventListener('click', () => {
      input.value = null; // reset
      input.click();
    });

    // Update transform of imageWrapper based on originX, originY, scale
    function updateTransform() {
      imageWrapper.style.transform = `translate(${originX}px, ${originY}px) scale(${scale})`;
    }

    // PAN imageWrapper
    container.addEventListener('mousedown', (e) => {
      // Só pan se clicar fora da área OCR
      if (ocrRegion.contains(e.target)) return;

      e.preventDefault();
      isPanning = true;
      startPanX = e.clientX - originX;
      startPanY = e.clientY - originY;
      container.style.cursor = 'grabbing';
    });
    window.addEventListener('mouseup', () => {
      isPanning = false;
      container.style.cursor = 'grab';
    });
    window.addEventListener('mousemove', (e) => {
      if (!isPanning) return;
      e.preventDefault();
      originX = e.clientX - startPanX;
      originY = e.clientY - startPanY;
      updateTransform();
    });

    // ZOOM imagem pelo scroll
    container.addEventListener('wheel', (e) => {
      if (ocrRegion.contains(e.target)) return; // Não zoom na área OCR

      e.preventDefault();

      // Zoom focado na posição do mouse
      const zoomIntensity = 0.1;
      const wheel = e.deltaY < 0 ? 1 : -1;
      const newScale = Math.min(Math.max(0.2, scale + wheel * zoomIntensity), 5);

      // Calcula ajuste para manter o ponto do mouse fixo
      const rect = container.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      originX -= (mx / scale - mx / newScale);
      originY -= (my / scale - my / newScale);

      scale = newScale;
      updateTransform();
    }, { passive: false });

    // Drag da região OCR
    let isDragging = false, offsetX = 0, offsetY = 0;
    ocrRegion.addEventListener('mousedown', (e) => {
      if (e.target === handle) return; // Não pan na drag handle aqui
      e.preventDefault();
      isDragging = true;
      const rect = ocrRegion.getBoundingClientRect();
      offsetX = e.clientX - rect.left;
      offsetY = e.clientY - rect.top;
      window.addEventListener('mousemove', onDrag);
      window.addEventListener('mouseup', stopDrag);
    });

    function onDrag(e) {
      if (!isDragging) return;
      e.preventDefault();
      const containerRect = container.getBoundingClientRect();
      let x = e.clientX - containerRect.left - offsetX;
      let y = e.clientY - containerRect.top - offsetY;

      // Limitar para não sair do container
      x = Math.max(0, Math.min(x, container.clientWidth - ocrRegion.offsetWidth));
      y = Math.max(0, Math.min(y, container.clientHeight - ocrRegion.offsetHeight));

      ocrRegion.style.left = `${x}px`;
      ocrRegion.style.top = `${y}px`;
      ocrRegion.style.transform = 'none';
    }
    function stopDrag() {
      isDragging = false;
      window.removeEventListener('mousemove', onDrag);
      window.removeEventListener('mouseup', stopDrag);
    }

    // Resize da região OCR
    let isResizing = false, startX, startY, startW, startH;
    handle.addEventListener('mousedown', (e) => {
      e.preventDefault();
      isResizing = true;
      const rect = ocrRegion.getBoundingClientRect();
      startX = e.clientX;
      startY = e.clientY;
      startW = rect.width;
      startH = rect.height;
      window.addEventListener('mousemove', onResize);
      window.addEventListener('mouseup', stopResize);
    });
    function onResize(e) {
      if (!isResizing) return;
      e.preventDefault();
      let newW = startW + (e.clientX - startX);
      let newH = startH + (e.clientY - startY);
      // Limitar tamanho mínimo e máximo
      newW = Math.min(Math.max(30, newW), container.clientWidth - ocrRegion.offsetLeft);
      newH = Math.min(Math.max(20, newH), container.clientHeight - ocrRegion.offsetTop);
      ocrRegion.style.width = `${newW}px`;
      ocrRegion.style.height = `${newH}px`;
    }
    function stopResize() {
      isResizing = false;
      window.removeEventListener('mousemove', onResize);
      window.removeEventListener('mouseup', stopResize);
    }

    // OCR button click
    ocrBtn.addEventListener('click', async () => {
      if (!preview.src) return;

      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');

      // Ajusta canvas para o tamanho natural da imagem
      canvas.width = preview.naturalWidth;
      canvas.height = preview.naturalHeight;

      // Desenha imagem original no canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(preview, 0, 0, canvas.width, canvas.height);

      // Pega posições da região OCR relativas à imagem natural considerando zoom e pan
      const containerRect = container.getBoundingClientRect();
      const regionRect = ocrRegion.getBoundingClientRect();

      const xRatio = preview.naturalWidth / container.clientWidth;
      const yRatio = preview.naturalHeight / container.clientHeight;

      // posição da região OCR relativa ao container ajustado pelo pan/zoom da imagem
      // precisamos levar em conta que a imagem está transformada (scale e translate)
      // Portanto, o OCR region (em container) precisa ser convertido para coordenadas da imagem original:

      // A imagem está em imageWrapper com transform: translate(originX, originY) scale(scale)
      // Então para a posição da região OCR (regionRect.left - containerRect.left)
      // precisamos compensar originX e scale.

      // calcular posição da região OCR em relação à imagem natural:
      const imgLeftInContainer = originX;
      const imgTopInContainer = originY;

      // posição da OCR region dentro do container:
      let regionLeftInContainer = regionRect.left - containerRect.left;
      let regionTopInContainer = regionRect.top - containerRect.top;

      // posição da OCR na imagem (antes do scale):
      let regionLeftInImage = (regionLeftInContainer - imgLeftInContainer) / scale;
      let regionTopInImage = (regionTopInContainer - imgTopInContainer) / scale;

      let regionWidthInImage = ocrRegion.offsetWidth / scale;
      let regionHeightInImage = ocrRegion.offsetHeight / scale;

            // Corrigir limites para não sair da imagem
      regionLeftInImage = Math.max(0, Math.min(regionLeftInImage, preview.naturalWidth));
      regionTopInImage = Math.max(0, Math.min(regionTopInImage, preview.naturalHeight));
      regionWidthInImage = Math.min(regionWidthInImage, preview.naturalWidth - regionLeftInImage);
      regionHeightInImage = Math.min(regionHeightInImage, preview.naturalHeight - regionTopInImage);

      // Recortar a região selecionada no canvas
      const imageData = ctx.getImageData(regionLeftInImage, regionTopInImage, regionWidthInImage, regionHeightInImage);

      // Criar um canvas temporário para a região OCR
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = regionWidthInImage;
      tempCanvas.height = regionHeightInImage;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.putImageData(imageData, 0, 0);

      resultDiv.textContent = "Reconhecendo texto…";

      // Usar Tesseract.js para OCR na região recortada
      Tesseract.recognize(
        tempCanvas,
        'por',
        { logger: m => console.log(m) }
      ).then(({ data: { text } }) => {
        resultDiv.textContent = text || "Nenhum texto encontrado.";
      }).catch(err => {
        resultDiv.textContent = "Erro no reconhecimento: " + err.message;
      });
    });
  </script>
</body>
</html>

