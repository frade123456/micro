<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="UTF-8" />
  <title>OCR com Zoom/Pan e Região OCR Independente</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body {
      margin: 0; padding: 0;
      font-family: Calibri, sans-serif;
      background: #fff;
    }
    #container {
      position: relative;
      width: 100vw;
      height: 80vh;
      background: #eee;
      overflow: hidden;
      user-select: none; /* evita seleção durante arrasto */
    }
    #image-wrapper {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      overflow: hidden;
      touch-action: none; /* para manipular gestos */
      cursor: grab;
    }
    #preview {
      position: absolute;
      top: 0; left: 0;
      transform-origin: 0 0; /* para o zoom partir do canto superior esquerdo */
      user-select: none;
      -webkit-user-drag: none;
      max-width: none; /* deixar o tamanho original para zoom */
    }
    #ocr-region {
      position: absolute;
      width: 60vw;
      height: 10vw;
      left: 50%;
      top: 40%;
      transform: translate(-50%, -50%);
      border: 2px dashed #ffb800;
      background: rgba(255, 255, 0, 0.1);
      z-index: 10;
      cursor: move;
      touch-action: none;
    }
    .resize-handle {
      width: 16px;
      height: 16px;
      background: #ffb800;
      position: absolute;
      right: -8px;
      bottom: -8px;
      cursor: se-resize;
      border-radius: 50%;
      border: 2px solid #000;
      z-index: 20;
    }
    #button-bar {
      display: flex;
      justify-content: center;
      gap: 1em;
      margin-top: 1em;
    }
    #button-bar button {
      padding: 1em 2em;
      background: #39f;
      color: white;
      font-size: 1.1em;
      font-weight: bold;
      border: none;
      border-radius: 6px;
      cursor: pointer;
    }
    #result {
      margin: 1em auto;
      text-align: center;
      font-size: 1.1em;
      font-weight: bold;
      max-width: 90vw;
      word-wrap: break-word;
    }
  </style>
</head>
<body>

  <input type="file" accept="image/*" capture="environment" id="camera-input" style="display: none;" />
  
  <div id="button-bar">
    <button id="capture-btn">Foto</button>
    <button id="ocr-btn" disabled>Ler Texto</button>
  </div>

  <div id="container">
    <div id="image-wrapper">
      <img id="preview" src="" alt="Pré-visualização" />
    </div>
    <div id="ocr-region">
      <div class="resize-handle"></div>
    </div>
  </div>

  <div id="result">Resultado aparecerá aqui…</div>

  <canvas id="canvas" style="display:none;"></canvas>

  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>
  <script>
    const input = document.getElementById('camera-input');
    const preview = document.getElementById('preview');
    const ocrRegion = document.getElementById('ocr-region');
    const ocrBtn = document.getElementById('ocr-btn');
    const resultDiv = document.getElementById('result');
    const imageWrapper = document.getElementById('image-wrapper');
    const handle = ocrRegion.querySelector('.resize-handle');

    // Variáveis para zoom e pan da imagem
    let scale = 1;
    let originX = 0;
    let originY = 0;
    let isPanning = false;
    let startPanX, startPanY;

    // Tirar foto
    document.getElementById('capture-btn').addEventListener('click', () => {
      input.value = null;
      input.click();
    });

    input.addEventListener('change', function () {
      const file = this.files[0];
      if (!file) return;

      const img = new Image();
      img.src = URL.createObjectURL(file);
      img.onload = function () {
        preview.src = img.src;
        preview.style.width = img.width + 'px';
        preview.style.height = img.height + 'px';

        // Reset zoom/pan
        scale = 1;
        originX = 0;
        originY = 0;
        updateTransform();

        // Posicionar imagem no centro
        originX = (imageWrapper.clientWidth - img.width) / 2;
        originY = (imageWrapper.clientHeight - img.height) / 2;
        updateTransform();

        // Ativa botão OCR e reset resultado
        ocrBtn.disabled = false;
        resultDiv.textContent = 'Ajuste a imagem e a área OCR, depois clique em "Ler Texto".';
      };
    });

    // Função para atualizar transform da imagem
    function updateTransform() {
      preview.style.transform = `translate(${originX}px, ${originY}px) scale(${scale})`;
    }

    // Pan da imagem
    imageWrapper.addEventListener('mousedown', (e) => {
      if (e.target === ocrRegion || ocrRegion.contains(e.target)) return; // não pan no ocr-region
      e.preventDefault();
      isPanning = true;
      startPanX = e.clientX - originX;
      startPanY = e.clientY - originY;
      imageWrapper.style.cursor = 'grabbing';
    });
    window.addEventListener('mousemove', (e) => {
      if (!isPanning) return;
      originX = e.clientX - startPanX;
      originY = e.clientY - startPanY;
      updateTransform();
    });
    window.addEventListener('mouseup', () => {
      isPanning = false;
      imageWrapper.style.cursor = 'grab';
    });

    // Zoom da imagem via roda do mouse (CTRL + roda para evitar scroll normal)
    imageWrapper.addEventListener('wheel', (e) => {
      e.preventDefault();

      // Ajusta zoom ao redor do ponto do mouse
      const rect = preview.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      const delta = e.deltaY < 0 ? 1.1 : 0.9;
      const newScale = Math.min(Math.max(scale * delta, 0.2), 5);

      // Corrige posição para zoom no ponto do mouse
      originX = e.clientX - ((mouseX / scale) * newScale);
      originY = e.clientY - ((mouseY / scale) * newScale);

      scale = newScale;
      updateTransform();
    }, { passive: false });

    // Drag da região OCR
    let isDragging = false, offsetX = 0, offsetY = 0;
    ocrRegion.addEventListener('mousedown', startDrag);
    ocrRegion.addEventListener('touchstart', startDrag, { passive: false });

    function startDrag(e) {
      if (e.target === handle) return;
      e.preventDefault();
      isDragging = true;
      const rect = ocrRegion.getBoundingClientRect();
      offsetX = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
      offsetY = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
      document.addEventListener('mousemove', onDrag);
      document.addEventListener('mouseup', stopDrag);
      document.addEventListener('touchmove', onDrag, { passive: false });
      document.addEventListener('touchend', stopDrag);
    }

    function onDrag(e) {
      if (!isDragging) return;
      e.preventDefault();
      const container = document.getElementById('container');
      const containerRect = container.getBoundingClientRect();
      let x = (e.touches ? e.touches[0].clientX : e.clientX) - offsetX - containerRect.left;
      let y = (e.touches ? e.touches[0].clientY : e.clientY) - offsetY - containerRect.top;

      // Limitar para não sair do container
      x = Math.min(containerRect.width - ocrRegion.offsetWidth, Math.max(0, x));
      y = Math.min(containerRect.height - ocrRegion.offsetHeight, Math.max(0, y));

      ocrRegion.style.left = x + 'px';
      ocrRegion.style.top = y + 'px';
      ocrRegion.style.transform = 'none';
    }

    function stopDrag() {
      isDragging = false;
      document.removeEventListener('mousemove', onDrag);
      document.removeEventListener('mouseup', stopDrag);
      document.removeEventListener('touchmove', onDrag);
      document.removeEventListener('touchend', stopDrag);
    }

    // Resize da região OCR
    let isResizing = false, startX, startY, startW, startH;
    handle.addEventListener('mousedown', startResize);
    handle.addEventListener('touchstart', startResize, { passive: false });

    function startResize(e) {
      e.preventDefault();
      isResizing = true;
      const rect = ocrRegion.getBoundingClientRect();
      startX = e.touches ? e.touches[0].clientX : e.clientX;
      startY = e.touches ? e.touches[0].clientY : e.clientY;
      startW = rect.width;
      startH = rect.height;
      document.addEventListener('mousemove', onResize);
      document.addEventListener('mouseup', stopResize);
      document.addEventListener('touchmove', onResize, { passive: false });
      document.addEventListener('touchend', stopResize);
    }

    function onResize(e) {
      if (!isResizing) return;
      e.preventDefault();
      const dx = (e.touches ? e.touches[0].clientX : e.clientX) - startX;
      const dy = (e.touches ? e.touches[0].clientY : e.clientY) - startY;
      ocrRegion.style.width = Math.max(30, startW + dx) + 'px';
      ocrRegion.style.height = Math.max(20, startH + dy) + 'px';
    }

    function stopResize() {
      isResizing = false;
      document.removeEventListener('mousemove', onResize);
      document.removeEventListener('mouseup', stopResize);
      document.removeEventListener('touchmove', onResize);
      document.removeEventListener('touchend', stopResize);
    }

    // Função OCR no botão
    ocrBtn.addEventListener('click', async () => {
      if (!preview.src) {
        alert('Tire uma foto primeiro!');
        return;
      }

      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');

      // Ajustar canvas para a imagem original
      const img = preview;
      canvas.width = img.naturalWidth;
      canvas.height = img.naturalHeight;
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Desenhar a imagem original (sem zoom/pan)
      ctx.drawImage(img, 0, 0);

      // Pega as posições da região OCR relativas ao container
      const containerRect = document.getElementById('container').getBoundingClientRect();
      const regionRect = ocrRegion.getBoundingClientRect();

      // Como o preview está com zoom/pan, convertemos posição da região para coordenadas da imagem original:
      // Passo 1: posição da região relativa ao container
      let relativeLeft = regionRect.left - containerRect.left;
      let relativeTop = regionRect.top - containerRect.top;

      // Passo 2: como a imagem está com zoom e translação, precisamos "desfazer" isso para obter posição correta na imagem original:
      // Como preview está transformado: translate(originX, originY) scale(scale)
      // Para obter a coordenada correta na imagem natural, ajustamos:
      // Coords na imagem natural = (pos - translate) / scale

      const x = (relativeLeft - originX) / scale;
      const y = (relativeTop - originY) / scale;
      const w = ocrRegion.offsetWidth / scale;
      const h = ocrRegion.offsetHeight / scale;

      // Pegando a imagem da região
      try {
        const imageData = ctx.getImageData(x, y, w, h);

        // Criar canvas temporário só com a região OCR
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = w;
        tempCanvas.height = h;
        tempCanvas.getContext('2d').putImageData(imageData, 0, 0);

        resultDiv.textContent = 'A processar...';

        const { data: { text } } = await Tesseract.recognize(
          tempCanvas,
          'por',
          {
            logger: m => console.log(m),
            tessedit_pageseg_mode: Tesseract.PSM.SINGLE_LINE
          }
        );
        resultDiv.textContent = 'Resultado: "' + text.trim() + '"';
      } catch (error) {
        resultDiv.textContent = 'Erro no OCR: ' + error.message;
      }
    });
  </script>
</body>
</html>
